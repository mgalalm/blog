[{"categories":["Web Development","Accessibility"],"content":"Screen readers, such as iOS VoiceOver, are essential tools for users with visual impairments, providing auditory feedback and allowing them to interact with digital content.\nWhat is iOS VoiceOver? VoiceOver is Apple\u0026rsquo;s built-in screen reader for iPhones and iPads. It reads on-screen elements aloud, allowing users to navigate using gestures and auditory feedback. Users can enable VoiceOver in Settings \u0026gt; Accessibility \u0026gt; VoiceOver or via Siri by saying, \u0026ldquo;Turn on VoiceOver.\u0026rdquo;\nUsing sr-only for Hidden from everyone but Screen Readers Sometimes, you may want to hide a label to maintain a clean design while still ensuring that screen readers can interpret the label correctly for users who rely on them.\nIn this example, you have a form with a text area for submitting comments. You want to hide the label \u0026ldquo;Comment\u0026rdquo; from the visual layout while still making it available to screen readers.\nHere\u0026rsquo;s an example where a label is hidden visually but still accessible to screen readers, using Tailwind CSS\u0026rsquo;s sr-only class.\n\u0026lt;InputLabel for=\u0026#34;body\u0026#34; class=\u0026#34;sr-only\u0026#34;\u0026gt;Comment\u0026lt;/InputLabel\u0026gt; \u0026lt;TextArea id=\u0026#34;body\u0026#34; v-model=\u0026#34;commentForm.body\u0026#34; rows=\u0026#34;4\u0026#34; placeholder=\u0026#34;Speak your mind Spock‚Ä¶\u0026#34;/\u0026gt; This approach maintains a clean, minimal design while ensuring that screen reader users can understand the purpose of the input field. It‚Äôs a great solution for creating accessible and visually appealing forms without compromising usability.\n","permalink":"http://localhost:1313/posts/lookfeel/enhancing-web-accessibility-with-screen-readers-and-tailwind-css/","tags":["Accessibility","Tailwind CSS","Screen Readers"],"title":"Enhancing Web Accessibility With Screen Readers and Tailwind Css"},{"categories":null,"content":"Have you ever encountered the dreaded \u0026ldquo;Not a valid Inertia response\u0026rdquo; error while testing Inertia in your Laravel app? ü§î Something\u0026rsquo;s happening in the meantime that is throwing an exception, but we\u0026rsquo;re not able to see that exception, all what we get is a broad message of \u0026ldquo;Not a valid Inertia response\u0026rdquo;\nWithout ExceptionHandling to rescue Adding the following line at the top of your test can make a world of difference\n$this-\u0026gt;withoutExceptionHandling(); This disables Laravel\u0026rsquo;s exception handling during the test, making sure Laravel isn\u0026rsquo;t going to get in the way during the test allowing you to see the raw error and its stack trace.\nExample Let\u0026rsquo;s look at a brief example to illustrate this, Let\u0026rsquo;s say you‚Äôre testing a dashboard interaction:\npublic function test_user_can_access_dashboard() { $response = $this-\u0026gt;actingAs(User::factory()-\u0026gt;create()) -\u0026gt;get(\u0026#39;/dashboard\u0026#39;); $response-\u0026gt;assertStatus(200); } If this test fails with \u0026ldquo;Not a valid Inertia response,\u0026rdquo; you can debug it by updating the test like this:\npublic function test_user_can_access_dashboard() { $this-\u0026gt;withoutExceptionHandling(); $response = $this-\u0026gt;actingAs(User::factory()-\u0026gt;create()) -\u0026gt;get(\u0026#39;/dashboard\u0026#39;); $response-\u0026gt;assertStatus(200); } Now, instead of a vague Inertia error, Laravel will reveal the actual issue‚Äîwhether it\u0026rsquo;s a route problem, a missing view, or an authorization failure.\n","permalink":"http://localhost:1313/posts/laravel/not-a-valid-inertia-response/","tags":null,"title":"Not a Valid Inertia Response"},{"categories":["Laravel","Cloud","AWS"],"content":"Hey there, Cloud enthusiast! If you‚Äôve ever wanted to send emails through Amazon SES (Simple Email Service) using Laravel, you‚Äôre in the right place. Amazon SES is reliable, scalable, and integrates beautifully with Laravel. Let‚Äôs dive into the steps to get it up and running in no time!\nStep 1: Install the Required Package To start, you‚Äôll need to install the aws/aws-sdk-php-laravel package. This package provides an easy way to interact with Amazon Web Services (AWS) services, including SES.\ncomposer require aws/aws-sdk-php-laravel Step 2: Configure Your AWS Credentials Next, you‚Äôll need to configure your AWS credentials. Open your .env file and add the following lines:\nAWS_ACCESS_KEY_ID=your-access-key-id AWS_SECRET_ACCESS_KEY=your-secret-access-key AWS_DEFAULT_REGION=your-default-region Replace your-access-key-id, your-secret-access-key, and your-default-region with your actual AWS credentials.\nStep 3: Configure the Mail Driver While you are in the .env file, make sure you have the following lines set up:\nMAIL_MAILER=ses MAIL_FROM_ADDRESS=[your verified email address] Note: The MAIL_FROM_ADDRESS must match an email address verified in your AWS SES console. If it‚Äôs not verified, Amazon SES won‚Äôt let you send emails. No extra setup is required in your config/mail.php file‚Äîit‚Äôs already set up to read from your .env file.\nStep 4: Send an Email Now you should get a good handle on how to send emails using Amazon SES in Laravel. We didn\u0026rsquo;t cover here how to configure Amazon SES itself in AWS Console, but you can find a detailed guide in the official documentation . Although, I will try to put together a guide on that in the future. Stay tuned!\n","permalink":"http://localhost:1313/posts/laravel/how-to-send-emails-using-amazon-ses-in-laravel/","tags":["Laravel","Cloud","AWS","Amazon SES"],"title":"How to Send Emails Using Amazon SES in Laravel"},{"categories":null,"content":"Avatar is a great way to personalize your application! They make user profiles more engaging and ensure everyone has a recognizable avatar when creating or commenting on posts. If you‚Äôre using Jetstream and want to enable custom profile photos, here‚Äôs a simple guide to get you started.\nUpdate the Configuration File Jetstream comes with a configuration file where you can enable or disable certain features. To enable profile photos:\nOpen the jetstream.php configuration file in your project‚Äôs config folder.\nLook for the features section. It should look something like this:\n\u0026#39;features\u0026#39; =\u0026gt; [ // Features::termsAndPrivacyPolicy(), Features::profilePhotos(), // Features::api(), // Features::teams([\u0026#39;invitations\u0026#39; =\u0026gt; true]), Features::accountDeletion(), ], Ensure that the Features::profilePhotos() line is uncommented. This line enables the profile photo feature in Jetstream.\nOnce you‚Äôve updated the configuration:\nRefresh your profile page in the browser.\nYou should see a new field to upload a profile photo.\nTroubleshooting Common Issues If you don‚Äôt see the profile photo field or encounter a 404 error or broken images, here are two common problems and how to fix them:\nStorage Link: Make sure you have created a symbolic link from public/storage to storage/app/public. You can do this by running: php artisan storage:link Incorrect APP_URL in .env: Ensure that the APP_URL in your .env file is correctly set to your application‚Äôs URL. This is crucial for loading images and assets correctly. If your application is accessible via a custom domain (e.g., http://app.test ) but the APP_URL in your .env file is set to http://localhost, the profile photos might not load correctly. Customizing Profile Photo Validation Now we have enabled the profile photo feature in Jetstream, but we might want to customize the validation rules for the uploaded photos for example, we might want to restrict the file types or sizes.\nTo customize the validation rules for profile photos, you can modify the UpdateProfileInformation action class under App\\Actions\\Fortify directory. In this class, you can find the update method where the profile photo is validated.\n\u0026#39;photo\u0026#39; =\u0026gt; [\u0026#39;nullable\u0026#39;, \u0026#39;mimes:jpg,jpeg,png\u0026#39;, \u0026#39;max:1024\u0026#39;], Wrapping Up! That‚Äôs it! With these simple steps, you‚Äôve enabled profile photos in Jetstream. Whether you‚Äôre building a blog, a social network, or any other type of app, this feature will make your users‚Äô profiles more vibrant and engaging. Enjoy!\n","permalink":"http://localhost:1313/posts/laravel/how-to-enable-profile-photos-in-jetstream/","tags":["Laravel","Jetstream"],"title":"How to Enable Profile Photos in Jetstream"},{"categories":null,"content":"Laravel Jetstream is a polished UI scaffolding package for Laravel applications. It provides developers with a refined starting point for building user interfaces, offering pre-built components and workflows for common features like authentication, profile management, and two-factor authentication.\nJetstream‚Äôs real power lies in its seamless integration with other Laravel features, enabling developers to focus on crafting unique application logic while leveraging robust, pre-configured workflows.\nWhat\u0026rsquo;s JetStream and what it\u0026rsquo;s actually doing? Jetstream acts as the user interface (UI) layer, focusing on front-end interactions and workflows. This separation of concerns allows developers to customize the front-end experience without worrying about the complexities of back-end implementation.\nJetstream supports two primary stacks:\nLivewire: For developers who prefer server-rendered pages with minimal JavaScript.\nVue with Inertia.js: For those who want a modern single-page application experience.\nFor instance, when a user updates their profile, Jetstream captures the input and routes it to the back end for processing. The actions executed depend on how Fortify has been configured in your application.\nInstalling Jetstream Jetstream is designed for fresh Laravel projects. To integrate Jetstream, follow these steps\nSet Up a New Laravel Application composer create-project laravel/laravel example-app cd example-app Install Jetstream Package\ncomposer require laravel/jetstream Install Jetstream\nphp artisan jetstream:installjetstream:install This will ask you to choose between Livewire and Vue with Inertia.js. Select the stack you prefer.\npublish Jetstream\u0026rsquo;s assets @php artisan vendor:publish --tag=laravel-assets --ansi --force That\u0026rsquo;s how jetstream look like when you go to the registration page of your application.\nJestream and Fortify Actions As we touched JetStream is pretty much just a UI layer and fortify is the workhorse that\u0026rsquo;s actually computing and working out how to update profile information, how to enable or disable two-factor authentication, how to manage browser sessions etc.\nWhen we install Jetstream, it comes with one action class which is DeleteUser, The DeleteUser action handles the removal of user accounts. By default, it:\nDeletes the user‚Äôs profile photo.\nRevokes all API tokens. Removes the user record from the database.\nHere‚Äôs the default implementation:\nclass DeleteUser implements DeletesUsers { /** * Delete the given user. */ public function delete(User $user): void { $user-\u0026gt;deleteProfilePhoto(); $user-\u0026gt;tokens-\u0026gt;each-\u0026gt;delete(); $user-\u0026gt;delete(); } } You can extend this logic to include additional cleanup tasks, such as logging the deletion or notifying team members.\nAlso when you install Jetsream, it install also fortify, which comes with the rest of the actions like UpdateUserProfileInformation, UpdateUserPassword, TwoFactorAuthentication etc.\n‚îî‚îÄ‚îÄ app ‚îú‚îÄ‚îÄ Actions ‚îÇ ‚îî‚îÄ‚îÄ Fortify ‚îÇ ‚îú‚îÄ‚îÄ CreateNewUser.php ‚îÇ ‚îú‚îÄ‚îÄ PasswordValidationRules.php ‚îÇ ‚îú‚îÄ‚îÄ ResetUserPassword.php ‚îÇ ‚îú‚îÄ‚îÄ UpdateUserPassword.php ‚îÇ ‚îî‚îÄ‚îÄ UpdateUserProfileInformation.php Conclusion Jetstream is a powerful tool for Laravel developers, providing a solid foundation for building user interfaces. By integrating Jetstream into your Laravel application, you can leverage pre-built components and workflows to streamline development and focus on crafting unique application logic. Jetstream‚Äôs seamless integration with other Laravel features makes it an excellent choice for developers looking to build robust, user-friendly applications.\n","permalink":"http://localhost:1313/posts/laravel/demystifying-laravel-jetstream/","tags":["Laravel","Jetstream"],"title":"Demystifying Laravel Jetstream"},{"categories":null,"content":"When working with Pest‚Äîthe modern and elegant testing framework for PHP‚Äîyou might encounter scenarios where a custom function is being used across multiple test files. Maybe it\u0026rsquo;s a function to mock a client request, handle repetitive setup tasks, or simulate specific data conditions. Whatever the case, it‚Äôs a great opportunity to extract that function to a reusable location. But where should you place it?\nThere are two common options:\nDefine it in your Pest.php file. Create a dedicated Helpers.php file. I prefer the second option for better organization. The Pest.php file handles global helpers and configurations but can become cluttered with reusable functions. Creating a Helpers.php file keeps things clean, and Pest automatically loads it without extra setup or namespaces.\nSetting Up Helpers.php First, create a Helpers.php file in your tests directory. This file will contain all your reusable functions. Here‚Äôs an example of a simple function that mocks a client request:\nuse App\\Clients\\StockStatus; use Facades\\App\\Clients\\ClientFactory; use Cknow\\Money\\Money; function mockClientRequest($available, $price) { ClientFactory::shouldReceive(\u0026#39;make-\u0026gt;checkAvailability\u0026#39;) -\u0026gt;andReturn(new StockStatus($available, Money::parse($price))); } Using the Helper Function in Tests Here‚Äôs how you can use the mockClientRequest function in your Pest tests:\nit(\u0026#39;updates local status after tracking\u0026#39;, function () { - ClientFactory::shouldReceive(\u0026#39;make-\u0026gt;checkAvailability\u0026#39;)-\u0026gt;andReturn(new StockStatus($available, Money::parse($price))); + mockClientRequest(available: true, price: \u0026#39;¬£299.99\u0026#39;); $stock = tap(Stock::first())-\u0026gt;track(); $this-\u0026gt;assertTrue($stock-\u0026gt;in_stock); $this-\u0026gt;assertEquals(29999, $stock-\u0026gt;price); // Price in cents $this-\u0026gt;assertEquals(\u0026#39;GBP\u0026#39;, $stock-\u0026gt;currency); }); What Happens? Mocking requests: Simulates client response with availability and price.\nTracking stock: Updates the database using mocked data.\nAssertions: Verifies stock status, price, and currency, using the new custom function.\nFinal Thoughts Extracting functions into Helpers.php improves test suite clarity and maintainability. It saves time and keeps your workflow organized. Pest‚Äôs ability to autoload this file makes it effortless to reuse functions across your test suite. Give it a try and see how it enhances your testing experience.\n","permalink":"http://localhost:1313/posts/laravel/extracting-and-reusing-functions-in-pest-tests/","tags":null,"title":"Extracting and Reusing Functions in Pest Tests"},{"categories":null,"content":"When my extractor fan stopped working, it made a loud noise and gave off a burning smell. I switched it off, knowing it was time for a replacement. Not being an expert, I removed the cover, snapped a photo of the fan, and consulted ChatGPT. It identified the model and explained the wiring, giving me confidence to proceed.\nAmazon had a replacement, but delivery wouldn‚Äôt arrive before Christmas. Adding to the challenge, finding an electrician to fix it during the holiday season would have been nearly impossible, despite the cost. I headed to Screwfix, where they suggested a similar alternative. Unsure if it would work, I checked with ChatGPT again and got the go-ahead. Reassured, I bought the fan.\nBack home, I had the next day off work, which gave me the perfect opportunity to tackle this project. It was my first time doing anything electrical. While I had done other handy jobs around the house, this felt like a big step.\nTo be safe, I switched off all the appliances, including the fridge and desktop, before turning off the main switch from the switchboard. I unscrewed the three wires first: the live (brown), neutral (blue), and earth (green/yellow). Then, I unscrewed the three wall screws and removed the entire fan from the wall. It was shocking to see the amount of dust it had accumulated.\n=100x {width=\u0026lsquo;100px \u0026lsquo;}\nNow it was time to install the new extractor, only to find that the hole for the wires was too small. Looking back at the old fan, I realized a new hole had been manually made by the previous electrician, as the wires were positioned in the left-right corner.\nI had to make a new hole, but I didn‚Äôt have the right tools. I tried using a screwdriver, but it was too slow. I use the drill with a spade drill bit, which made the job much easier. I then fed the wires through the hole and connected them to the new fan, and screwed it back into the wall.\nI turned on the main switch and then the fan. It worked! I was relieved. I cleaned up the mess and put everything back in place. I couldn‚Äôt have done it without ChatGPT‚Äôs help. It was a great learning experience, and I felt more confident about doing other DIY projects in the future.\n","permalink":"http://localhost:1313/posts/beyondcode/replacing-a-faulty-extractor-fan-with-chatgpt-s-help/","tags":null,"title":"Replacing a Faulty Extractor Fan With Chatgpt Help"},{"categories":null,"content":"Imagine this: you‚Äôre running your test suite every time you make a change, but instead of your tests zipping through like a speedster, they keep calling an evolving 3rd party API that you need to make sure your code is still compatible with.\nYou‚Äôre not only waiting for your tests to finish, but you‚Äôre also paying for the API calls. This is a common scenario in the world of testing, and it can be a real pain in the neck. In this article, we‚Äôll explore how to keep your test suite under control without breaking the bank.\nIntegration Tests Are Heavy Integration tests are awesome because they ensure your application works as a whole, including those tricky external APIs. But here‚Äôs the rub:\nThey‚Äôre expensive: Each test call to an external API takes time and bandwidth. They‚Äôre unnecessary (most of the time): Do you really need to test that API call every single time you update a CSS file? Nope. Group Your Tests Like a Pro Laravel and Pest make it ridiculously easy to organize and control your test suite. We can mark specific tests as part of an \u0026ldquo;API\u0026rdquo; group and exclude them when we run our suite during regular development. Here‚Äôs how.\nStep 1: Create a Test Group You can organize your integration tests into a specific folder, like tests/Integration. Then, use a group to mark them as belonging to an API category.\nAdd a Test Suite in phpunit.xml Update your phpunit.xml to include a dedicated test suite for integration tests:\ntests/Integration Step 2 Configure Groups in Pest If you‚Äôre using Pest‚Äîand you should because it‚Äôs clean and fun‚Äîyou can extend it to include your integration tests. Update your Pest.php file like this:\npest()-\u0026gt;extend(Tests\\TestCase::class) // Add other test configurations here if needed -\u0026gt;in(targets: \u0026#39;Integration\u0026#39;); Step 3: Exclude the Group When Running Tests Here‚Äôs the magic. When running your test suite, simply exclude the integration group during your normal development workflow:\nphp artisan test --exclude-group integration This command skips those heavy integration tests while letting you focus on the rest of your suite\nWhen to Run Integration Tests? You might be thinking, ‚ÄúIf I‚Äôm excluding integration tests, when do I actually run them?‚Äù Good question! Here‚Äôs when:\nOn Deployment: Make it part of your CI/CD pipeline. Integration tests can run once before your code ships to production. Sporadically: Running them manually every now and then is enough to ensure external APIs still behave as expected. When You‚Äôre Testing Changes to External APIs: Any changes to API-related logic should prompt a full run of these tests. Why This Approach Works This setup keeps your test suite lean during development but ensures those critical integration tests don‚Äôt get ignored. It‚Äôs a win-win:\nFaster Feedback: Running tests is quicker when you skip integration tests during active coding. Save API Limits: No need to bombard external APIs with every little code change. Less Frustration: Your team (and your future self) will thank you for keeping the test suite manageable ###TL;DR: Don\u0026rsquo;t Let Integration Tests Weigh You Down\nTesting should empower you, not slow you down. By grouping your integration tests and excluding them when you don‚Äôt need them, you can run your suite as often as you like without fear of wasting resources or time.\n","permalink":"http://localhost:1313/posts/laravel/how-to-keep-your-test-suite-under-control-without-breaking-the-bank/","tags":null,"title":"How to Keep Your Test Suite Under Control Without Breaking the Bank"},{"categories":null,"content":"Table Topics are a great way to practice impromptu speaking. Here are some fun and creative topics to get you started:\nWhat happens when Santa holds an election for Head Elf? Campaign promises and all If you could invent a toy that would be loved by children from every culture, what would it be? How can we tell if brain microchip technology is already being used in society today? You‚Äôre stuck in the longest line during Christmas shopping, and you really need to get ahead. What creative (and completely ridiculous) excuses do you use to cut the line without anyone noticing? If you were stuck in a pub during the storm, what three things would you want with you? You‚Äôre sitting quietly at a funeral when you suddenly hear your name called out‚Äîit‚Äôs your turn to give a speech. You get up, walk to the podium, and halfway down the aisle, you look back at the people it hits you: this isn‚Äôt the right funeral! The person you‚Äôre speaking about isn‚Äôt the one you thought. Also the people are looking forward to your speech so it is cruel to let them down. What do you do?\nWhat would you do if you woke up one morning and discovered a cow was in your front yard eating grass? If you were taking a driving test in a world where oil is extinct and donkeys are the only means of transport, what unique skills would you need to master to pass the test? ","permalink":"http://localhost:1313/posts/beyondcode/some-table-topics-with-the-help-of-grok2/","tags":null,"title":"Some Table Topics With the Help of Grok2"},{"categories":["Programming","Laravel"],"content":"Ever tried to mock a Demeter chain in PHP? It\u0026rsquo;s like trying to thread a needle with a rope. Let‚Äôs break it down with an example using Laravel.\nExample of a Demeter Chain Imagine you\u0026rsquo;re working with Laravel, and you have this glorious chain:\n$order = Order::find($id); $status = $order-\u0026gt;payment-\u0026gt;transaction-\u0026gt;status; Here, we\u0026rsquo;re grabbing an Order, navigating through its payment, then through its transaction, to get the status.\nNow you want to test something, and this chain decides to make your life miserable:\nToo Many Mocks: For this to work, you need mocks for: The Order object. The Payment object. The Transaction object. Brittle Tests: Any change in the chain structure can break your test, even if the logic remains valid. $orderMock = Mockery::mock(Order::class); $paymentMock = Mockery::mock(Payment::class); $transactionMock = Mockery::mock(Transaction::class); $orderMock-\u0026gt;shouldReceive(\u0026#39;getAttribute\u0026#39;)-\u0026gt;with(\u0026#39;payment\u0026#39;)-\u0026gt;andReturn($paymentMock); $paymentMock-\u0026gt;shouldReceive(\u0026#39;getAttribute\u0026#39;)-\u0026gt;with(\u0026#39;transaction\u0026#39;)-\u0026gt;andReturn($transactionMock); $transactionMock-\u0026gt;shouldReceive(\u0026#39;getAttribute\u0026#39;)-\u0026gt;with(\u0026#39;status\u0026#39;)-\u0026gt;andReturn(\u0026#39;paid\u0026#39;); Order::shouldReceive(\u0026#39;find\u0026#39;)-\u0026gt;with($id)-\u0026gt;andReturn($orderMock); By the time you‚Äôre done, you‚Äôve mocked half the universe for a single test.ü§¶‚Äç‚ôÇÔ∏è\nMocking It Like a Pro Here‚Äôs the trick: you can mock the entire chain in one go.\n$orderMock = Mockery::mock(Order::class); $orderMock-\u0026gt;shouldReceive(\u0026#39;payment-\u0026gt;transaction-\u0026gt;status\u0026#39;)-\u0026gt;andReturn(\u0026#39;paid\u0026#39;); Order::shouldReceive(\u0026#39;find\u0026#39;)-\u0026gt;with($id)-\u0026gt;andReturn($orderMock); Boom! You just mocked the whole chain without creating a separate mock for Payment or Transaction. Clean and concise.\nWhy This Works Mockery‚Äôs ability to interpret chains (-\u0026gt;) makes it easy to handle this. No need to mock intermediate objects i.e Payment and Transaction ,you only care about the final result of the chain.\nFinal Thoughts When to Use This Quick Tests: Perfect for when you need to verify outcomes and don‚Äôt care about the internals. Focused Testing: Keeps your test simple and avoids diving into unnecessary layers of detail. The Catch This approach ties your test directly to the chain structure. If the chain changes (e.g., transaction becomes txn), your test will fail, even if the logic is still valid. To future-proof your test, always ask yourself: Do I care about the chain itself, or just the outcome?\n","permalink":"http://localhost:1313/posts/laravel/mocking-a-demeter-chain-in-php-the-shortcut-you-didn-t-know-you-had/","tags":["Laravel","Testing","Mocking","PHP"],"title":"Mocking a Demeter Chain in PHP the Shortcut You Didn't Know You Had"},{"categories":["Laravel","Testing"],"content":"In software development, especially when working with frameworks like Laravel, unit testing is crucial for ensuring code reliability and maintainability. Laravel integrates well with Mockery, a mocking framework for PHP, to help developers create test doubles. Let\u0026rsquo;s delve into the concepts of Stubs, Mocks, Doubles, and Spies, and how they\u0026rsquo;re used in Laravel testing scenarios.\nWhat are Test Doubles? Test doubles are objects that stand in for real objects during testing. They simulate the behavior of complex, real objects to isolate the code being tested. The term \u0026ldquo;test double\u0026rdquo; was coined by Gerard Meszaros to describe these stand-ins, which include stubs, mocks, dummies, fakes, and spies.\nStubs A stub is an object that provides predefined answers to calls made during a test, focusing on controlling the output of the dependency.\nWhen to use Stubs: Use stubs when you want to replace a method\u0026rsquo;s behavior with a fixed response. For example, when testing a method that interacts with a database, you can use a stub to return a predefined dataset instead of querying the database. Stubs are useful when you need to control the output of a method to test different scenarios.\n$stub = Mockery::mock(\u0026#39;MyClass\u0026#39;); $stub-\u0026gt;shouldReceive(\u0026#39;method\u0026#39;)-\u0026gt;andReturn(\u0026#39;foo\u0026#39;); This stub will return \u0026lsquo;foo\u0026rsquo; whenever the method is called. Example of usage would be: When you want to stub API call to return a specific response without actually making the network request.\nMocks Mocks are similar to stubs but they also verify interactions with the system under test. They expect certain methods to be called with specific parameters.\nWhen to use Mocks: Mocks are used when you need to assert that certain methods were called with the right parameters:\n$mock = Mockery::mock(\u0026#39;MyClass\u0026#39;); $mock-\u0026gt;shouldReceive(\u0026#39;method\u0026#39;)-\u0026gt;with(\u0026#39;foo\u0026#39;)-\u0026gt;once(); This mock will expect the method to be called with \u0026lsquo;foo\u0026rsquo; as a parameter exactly once. Example of usage would be: When you want to ensure that a method is called with specific parameters. For example, when testing a method that sends an email, you can use a mock to verify that the email was sent with the correct subject and body.\nSpies Spies are test doubles that record calls made during the test, allowing assertions after the fact rather than setting expectations beforehand. Spies are useful for verifying that methods get called without prescribing how they should be called:\n$spy = Mockery::spy(\u0026#39;MyService\u0026#39;); // Perform some action that should call \u0026#39;method\u0026#39; on \u0026#39;MyService\u0026#39; $spy-\u0026gt;shouldHaveReceived(\u0026#39;method\u0026#39;); Example would be, If you\u0026rsquo;re testing event broadcasting in Laravel, you might use a spy to ensure an event was dispatched without caring about the specific details of the event data.\nFinal Thoughts Choosing between stubs, mocks, doubles, and spies depends on the specific requirements of your test. Stubs are useful when you want to control the output of a method, mocks are used to verify interactions, and spies are helpful for verifying calls after the fact. By understanding the differences between these test doubles, you can write more effective and maintainable tests in your Laravel applications.\n","permalink":"http://localhost:1313/posts/laravel/stubs-mocks-double-and-spies-when-to-use-one-over-the-other/","tags":["Laravel","Testing","Mockery","Unit Testing"],"title":"Stubs Mocks Double and Spies When to Use One Over the Other?"},{"categories":["Programming","Laravel"],"content":"In PHP, particularly within frameworks like Laravel, facades provide a static-like interface to classes available in the service container. Here, we delve into the concept of real-time facades, which allow you to treat any class in your application as if it were a facade, enhancing your ability to mock dependencies for testing.\nUnderstanding Real-Time Facades for Mocking When employing real-time facades, you essentially use the Facades namespace before the path of the class you intend to mock or interact with. This approach dynamically creates facade access for any class without needing to define a specific facade class.\nLet\u0026rsquo;s start by looking at how we might use a class without real-time facades:\nuse App\\Clients\\ClientFactory; Here, ClientFactory is used directly. However, when you apply the real-time facade concept, you alter the usage like this:\nuse Facades\\App\\Clients\\ClientFactory; By using Facades before App\\Clients\\ClientFactory, you\u0026rsquo;re instructing PHP to resolve the ClientFactory from the service container as if it were a facade. This is powerful for mocking because:\nDependency Injection: The actual implementation is resolved from the container, adhering to the principles of dependency injection. Mocking: You can easily mock this facade for testing purposes. For example: ClientFactory::shouldReceive(\u0026#39;make\u0026#39;)-\u0026gt;andReturn(new class implements Client { public function checkAvailability(Stock $stock): StockStatus { return new StockStatus($available = true, $price = 9900); } }); This line mocks the make method of ClientFactory to return a FakeClient instance, which is particularly useful in unit testing where you want to control what the make method does.\nImplementation in Your Code for Mocking To use this real-time facade approach in your testing environment, you need to adjust the class usage in your code as well. Here\u0026rsquo;s how you might implement it:\n- use App\\Clients\\ClientFactory; + use Facades\\App\\Clients\\ClientFactory; This change allows you to mock the ClientFactory class in your tests, providing a more controlled environment for testing.\nConclusion Real-time facades simplify the interaction with classes in your application, making them behave like facades with minimal setup. This technique enhances both development and testing by allowing more flexible and mockable code structures. If you\u0026rsquo;re working in environments where dynamic instantiation from a container is beneficial, embracing real-time facades can significantly streamline your mocking process during testing.\n","permalink":"http://localhost:1313/posts/laravel/mocking-classes-with-real-time-facades/","tags":["Laravel","Testing","Facades","Mocking"],"title":"Mocking Classes With Real Time Facades"},{"categories":["Programming","Laravel"],"content":"Testing Exceptions. In this post, we\u0026rsquo;ll explore how to create and test custom exceptions effectively, enhancing the reliability of your applications.\nWhy Custom Exceptions? Using a custom exception, like OrderNotFoundException, instead of general exceptions (Exception, RuntimeException, etc.), provides several benefits:\nSpecificity: It clearly communicates what went wrong, making debugging and error handling more precise. Organization: Custom exceptions help in organizing your application\u0026rsquo;s error handling logic. You can define specific behaviors or additional data for each type of exception. Code Readability: When someone reads or works with your code, custom exceptions immediately convey the context of errors, improving code clarity. Creating Custom Exceptions First, create a custom exception:\nphp artisan make:Exception OrderNotFoundException This command generates a new exception class in the app/Exceptions directory.\nModify OrderNotFoundException.php\n\u0026lt;?php namespace App\\Exceptions; use Exception; class OrderNotFoundException extends Exception { /** * Render the exception into an HTTP response. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function render($request) { return response()-\u0026gt;json([\u0026#39;error\u0026#39; =\u0026gt; \u0026#39;Order not found\u0026#39;], 404); } } Testing Exceptions with PEST When testing for non-custom exceptions, Laravel\u0026rsquo;s PHPUnit integration allows you to use expectException to anticipate exceptions:\n/** @test */ public function it_throws_an_invalid_argument_exception() { $this-\u0026gt;expectException(\\InvalidArgumentException::class); // Code that should throw the exception $this-\u0026gt;withoutExceptionHandling()-\u0026gt;get(\u0026#39;/invalid-route\u0026#39;); } Make sure to place $this-\u0026gt;expectException() at the start of your test to signal Pest about the expected exception, not after the failing code.\nTest Exception Messages: You can also check the message of the exception using expectExceptionMessage:\n$this-\u0026gt;expectExceptionMessage(\u0026#39;Order with ID 123456789 does not exist\u0026#39;); Conclusion Testing exceptions with Pest in Laravel enhances your application\u0026rsquo;s reliability and user experience. By employing Pest\u0026rsquo;s clear syntax and Laravel\u0026rsquo;s testing features, you can:\nEnsure Robust Error Handling: Verify that your application responds correctly to errors. Improve Code Quality: Use specific exceptions for better code clarity and maintenance. Enhance User Experience: Deliver informative feedback in case of errors.\nRemember, exceptions serve as signals for specific conditions within your application. Testing these with Pest ensures your application remains robust against unexpected scenarios.\n","permalink":"http://localhost:1313/posts/laravel/laravel-testing-mastering-exception-scenarios/","tags":["Laravel","Testing","Exceptions"],"title":"Laravel Testing  Mastering Exception Scenarios"},{"categories":["Testing","Laravel"],"content":"In the dynamic world of Laravel development, ensuring your code is well-tested isn\u0026rsquo;t just good practice; it\u0026rsquo;s essential for creating robust applications. Code coverage serves as a critical metric to assess the extent to which your tests cover your codebase.\nThis guide will walk you through setting up Xdebug for code coverage in Laravel, along with troubleshooting common issues. When you first attempt to run:\nphp artisan test --coverage you might encounter an error like: ERROR Code coverage driver not available. Did you set Xdebug\u0026rsquo;s coverage mode?\nThis indicates that Xdebug might not be installed or configured correctly for coverage analysis.\nRoute::get(\u0026#39;/test\u0026#39;, function () { phpinfo(); return \u0026#39;test\u0026#39;; }); Visit /test in your browser and look for Xdebug details.\nNavigate to Xdebug Wizard Paste the phpinfo() output into the wizard for analysis to ensure Xdebug is correctly installed.\nIf it\u0026rsquo;s installed locate the php.ini by searching for it in the html output.\nEditing php.ini with vim sudo nano /path/to/your/php.ini Add or modify the following lines:\nxdebug.mode = debug,coverage xdebug.start_with_request = yes Running Code Coverage Again Now, execute:\nphp artisan test --coverage This should now work, providing coverage statistics.\n","permalink":"http://localhost:1313/posts/laravel/mastering-laravel-testing-turbocharge-your-code-coverage-with-xdebug/","tags":["Laravel","Testing","Code Coverage","Xdebug"],"title":"Turbocharge Your Code Coverage With Xdebug"},{"categories":null,"content":"Let\u0026rsquo;s dive into the world of Laravel seeders used with Pest.\nSetting Up Data with Seeders Here\u0026rsquo;s a snippet of how you might use a seeder:\n$my_book = Product::create([\u0026#39;name\u0026#39; =\u0026gt; \u0026#34;Zayn and Grandad\u0026#39;s Van\u0026#34;]); $amazon_uk = Retailer::create([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Amazon UK\u0026#39;]); $stock = new Stock([ \u0026#39;price\u0026#39; =\u0026gt; 2000, \u0026#39;url\u0026#39; =\u0026gt; \u0026#39;http://www.amazon.uk\u0026#39;, \u0026#39;in_stock\u0026#39; =\u0026gt; false, \u0026#39;sku\u0026#39; =\u0026gt; \u0026#39;12345\u0026#39;, ]); $amazon_uk-\u0026gt;addStock($my_book, $stock); Writing Tests with Pest uses(RefreshDatabase::class); it(\u0026#34;tracks products stock\u0026#34;, function () { $this-\u0026gt;seed(RetailerWithProductSeeder::class); $product = Product::first(); $this-\u0026gt;assertFalse($product-\u0026gt;inStock()); Http::fake(fn() =\u0026gt; [\u0026#39;available\u0026#39; =\u0026gt; true, \u0026#39;price\u0026#39; =\u0026gt; 29900]); // Let\u0026#39;s pretend the stock is available now $this-\u0026gt;artisan(\u0026#39;track\u0026#39;); $this-\u0026gt;assertTrue(Product::first()-\u0026gt;inStock()); }); RefreshDatabase clears the database before each test, ensuring no old data messes with your results.\nAdvantages of Using Seeders with Pest Efficient Setup: Seeders mean you\u0026rsquo;re not rewriting the same setup code for every test. It\u0026rsquo;s like cooking dinner where the prep work is already done. Reuse: Seeders are reusable across your tests. Think of them as a favorite recipe you pull out whenever needed. Realistic Scenarios: They let you craft complex, real-world-like data setups. Great for when you want to test how your app behaves in varied conditions On Readability: Outside Context: When you see RetailerWithProductSeeder::class, you\u0026rsquo;ve got to go look elsewhere to understand what data it\u0026rsquo;s seeding. It\u0026rsquo;s like a film reference that makes you want to check the movie out to get the full picture. Debugging Complexity: If things go wrong, you\u0026rsquo;re not just debugging the test; you\u0026rsquo;re also looking at what the seeder\u0026rsquo;s doing. Adds a bit of detective work to your debugging process. Test Isolation: Mess with the seeder, and you might find a bunch of your tests falling apart. It\u0026rsquo;s like a domino effect; one goes down, and they all might. Implicit Reset: The RefreshDatabase trait ensures each test begins afresh, which is great, but might not be immediately obvious to someone new to the code. To sum up, combining seeders with Pest in Laravel is quite handy for managing your test data, but it does introduce some readability considerations. Make sure to keep your seeders well-documented and perhaps sprinkle some comments in your tests to make life easier for the next developer who looks at your code.\n","permalink":"http://localhost:1313/posts/laravel/laravel-seeders-and-pest-a-casual-look/","tags":["Laravel","Testing","Pest","Seeders"],"title":"Laravel Seeders and Pest: A Casual Look"},{"categories":null,"content":"In Laravel, one of the powerful tools for testing is the ability to simulate HTTP responses without actually hitting an external API. This is particularly useful when you need to ensure your application behaves correctly regardless of the API\u0026rsquo;s response.\nHere\u0026rsquo;s how you can use Http::fake() to test a scenario where you\u0026rsquo;re checking the stock status and price of an item from an Amazon-like service.\nThe Tracking Functionality Let\u0026rsquo;s consider a method track() in a Stock model which checks the stock status and price from an external service:\npublic function track() { if ($this-\u0026gt;retailer-\u0026gt;name === \u0026#39;Amazon UK\u0026#39;) { $results = Http::get(\u0026#39;http://foo.test\u0026#39;)-\u0026gt;json(); $this-\u0026gt;update([ \u0026#39;in_stock\u0026#39; =\u0026gt; $results[\u0026#39;available\u0026#39;], \u0026#39;price\u0026#39; =\u0026gt; $results[\u0026#39;price\u0026#39;], ]); } } This function assumes that when it makes an HTTP GET request to http://foo.test , it receives JSON data with keys available and price.\nFaking the HTTP Response To test this method without real network calls, we can use Laravel\u0026rsquo;s Http::fake() method:\n/** @test */ it(\u0026#34;tracks products stock\u0026#34;, function () { // Fake the HTTP response for \u0026#39;foo.test\u0026#39; Http::fake([ \u0026#39;foo.test\u0026#39; =\u0026gt; Http::response([ \u0026#39;available\u0026#39; =\u0026gt; false, \u0026#39;price\u0026#39; =\u0026gt; 2000, ], 200) ]); // Setup the stock instance $stock = new Stock([ \u0026#39;price\u0026#39; =\u0026gt; 2000, \u0026#39;url\u0026#39; =\u0026gt; \u0026#39;http://www.amazon.uk\u0026#39;, \u0026#39;in_stock\u0026#39; =\u0026gt; true, // Initially, we assume it\u0026#39;s in stock \u0026#39;sku\u0026#39; =\u0026gt; \u0026#39;12345\u0026#39;, ]); // Assuming $amazon_uk is an instance of a Retailer model or similar $amazon_uk-\u0026gt;addStock($my_book, $stock); // Call the track method which should update the stock $stock-\u0026gt;track(); // Assert that the stock is now reflected as not in stock $this-\u0026gt;assertFalse($stock-\u0026gt;fresh()-\u0026gt;in_stock); }); How it works We use Http::fake() to define what http://foo.test should respond with. Here, we\u0026rsquo;re saying it should return a JSON response with available set to false and price at 2000.\nWhy Use Http::fake()? Consistency: Tests are not dependent on external service availability or data changes. Speed: Reduces test time by avoiding actual HTTP requests. Isolation: Keeps tests isolated from the network and external dependencies, making them more reliable and easier to maintain. By leveraging Http::fake(), you can thoroughly test how your application handles different scenarios from external APIs without the need for actual integration with those services during your test runs. This approach is essential for developing robust, reliable, and efficient applications.\n","permalink":"http://localhost:1313/posts/laravel/testing-with-fake-http-laravel/","tags":["Laravel","Testing","HTTP","Fake"],"title":"Testing with Fake HTTP Requests in Laravel"},{"categories":["PHP","Laravel","Testing"],"content":" Testing is a critical part of software development, ensuring that applications behave as expected. Laravel, known for its elegant syntax and developer-friendly features, has been paired beautifully with Pest, an innovative testing framework for PHP. Here\u0026rsquo;s how to leverage Pest for writing tests in Laravel.\nWhy Pest? Pest brings some delightful features to the table:\nFluent Syntax: Write tests that are readable like natural language. Higher Order Functions: Simplifies the process of setting up and tearing down test environments. Built-in Expectations: Comes with sensible default assertions. Installing Pest To begin, you need to install Pest in your Laravel application. Here are the steps:\nAdd Pest to your project:\ncomposer require pestphp/pest-plugin-laravel --dev vendor/bin/pest --init This command will create the necessary configuration files for Pest within your Laravel project\n","permalink":"http://localhost:1313/posts/laravel/testing-laravel-with-pest/","tags":["Laravel","PHP","Testing","Pest"],"title":"Testing Laravel Applications with Pest"},{"categories":null,"content":"","permalink":"http://localhost:1313/manifest.json","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.de/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.es/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.fr/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.hi/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.jp/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.nl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.pl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.ru/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.zh-cn/","tags":null,"title":""}]